<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval'; script-src * 'unsafe-inline' 'unsafe-eval'; connect-src * 'unsafe-inline'; img-src * data: blob: 'unsafe-inline'; frame-src *; style-src * 'unsafe-inline';">
    <title>Our Squad is Top.. Click to Continue...</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            background-color: #000;
        }
        canvas { 
            display: block; 
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 2em;
            text-align: center;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading">Our Squad is Top</div>
    <div id="controls">Press SPACE to toggle camera view</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.159.0/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Constants
        const SOLAR_SYSTEM_SCALE = 200;
        const SUN_SIZE = 20;
        const TIME_SCALE = 0.5; // Adjust this to speed up/slow down the entire system

        // Accurate orbital periods in Earth days
        const ORBITAL_PERIODS = {
            mercury: 88,
            venus: 225,
            earth: 365,
            mars: 687,
            jupiter: 4333,
            saturn: 10759,
            uranus: 30687,
            neptune: 60190
        };

        // Texture loader
        const textureLoader = new THREE.TextureLoader();

        // Create Milky Way background
        const createMilkyWayBackground = () => {
            const geometry = new THREE.SphereGeometry(5000, 64, 64);
            // Flip the geometry inside out
            geometry.scale(-1, 1, 1);

            const material = new THREE.MeshBasicMaterial({
                map: textureLoader.load('milkyway.jpg'),
                side: THREE.BackSide
            });

            const mesh = new THREE.Mesh(geometry, material);
            // Rotate to correct orientation
            mesh.rotation.z = Math.PI / 2;
            scene.add(mesh);
        };

        // Planet data
        const planetData = [
            { name: 'Sun', size: 1, distance: 0, texture: '2k_sun.jpg', emissive: true },
            { name: 'Mercury', size: 0.038, distance: 50, texture: '2k_mercury.jpg', period: ORBITAL_PERIODS.mercury },
            { name: 'Venus', size: 0.095, distance: 75, texture: '2k_venus_surface.jpg', period: ORBITAL_PERIODS.venus },
            { name: 'Earth', size: 0.1, distance: 100, texture: '2k_earth_daymap.jpg', period: ORBITAL_PERIODS.earth },
            { name: 'Mars', size: 0.053, distance: 150, texture: '2k_mars.jpg', period: ORBITAL_PERIODS.mars },
            { name: 'Jupiter', size: 1.12, distance: 250, texture: '2k_jupiter.jpg', period: ORBITAL_PERIODS.jupiter },
            { name: 'Saturn', size: 0.945, distance: 350, texture: '2k_saturn.jpg', period: ORBITAL_PERIODS.saturn },
            { name: 'Uranus', size: 0.4, distance: 400, texture: '2k_uranus.jpg', period: ORBITAL_PERIODS.uranus },
            { name: 'Neptune', size: 0.388, distance: 450, texture: '2k_neptune.jpg', period: ORBITAL_PERIODS.neptune }
        ];

        // Moon data (Earth's moon with texture, others with basic materials)
        const moonData = {
            earth: { size: 0.027, distance: 15, texture: '2k_moon.jpg', period: 27.3 },
            mars: [
                { name: 'Phobos', size: 0.005, distance: 8, color: 0x888888, period: 0.3 },
                { name: 'Deimos', size: 0.003, distance: 12, color: 0x666666, period: 1.2 }
            ],
            // Add other moons as needed
        };

        // Create planets
        const planets = planetData.map(data => {
            const planetGroup = new THREE.Group();

            const geometry = new THREE.SphereGeometry(SUN_SIZE * data.size, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                map: textureLoader.load(data.texture),
                shininess: data.emissive ? 0 : 30
            });

            if (data.emissive) {
                material.emissive = new THREE.Color(0xffff00);
                material.emissiveIntensity = 0.5;
            }

            const planet = new THREE.Mesh(geometry, material);

            if (data.distance > 0) {
                planet.position.x = data.distance;
            }

            planetGroup.add(planet);
            scene.add(planetGroup);

            // Add moons if applicable
            if (moonData[data.name.toLowerCase()]) {
                const moons = Array.isArray(moonData[data.name.toLowerCase()]) ? 
                    moonData[data.name.toLowerCase()] : [moonData[data.name.toLowerCase()]];

                moons.forEach(moon => {
                    const moonGroup = new THREE.Group();
                    const moonGeometry = new THREE.SphereGeometry(SUN_SIZE * moon.size, 16, 16);
                    const moonMaterial = moon.texture ? 
                        new THREE.MeshPhongMaterial({ map: textureLoader.load(moon.texture) }) :
                        new THREE.MeshPhongMaterial({ color: moon.color });

                    const moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
                    moonMesh.position.x = moon.distance;
                    moonGroup.add(moonMesh);
                    planet.add(moonGroup);
                });
            }

            return planetGroup;
        });

        // Lighting
        const sunLight = new THREE.PointLight(0xffffff, 2, SOLAR_SYSTEM_SCALE * 4);
        scene.add(sunLight);
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Camera setup
        camera.position.set(0, 200, 400);
        camera.lookAt(scene.position);

        let useMainCamera = true;
        const altCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        altCamera.position.set(0, 300, 600);

        // Handle camera toggle
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                useMainCamera = !useMainCamera;
            }
        });

        // Animation
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime() * TIME_SCALE;

            // Animate planets
            planets.forEach((planetGroup, index) => {
                if (index > 0) { // Skip sun
                    const data = planetData[index];
                    const orbitalSpeed = (2 * Math.PI) / data.period;
                    const angle = time * orbitalSpeed;

                    planetGroup.position.x = Math.cos(angle) * data.distance;
                    planetGroup.position.z = Math.sin(angle) * data.distance;

                    // Planet rotation
                    const planet = planetGroup.children[0];
                    planet.rotation.y += 0.02 / data.period;
                }
            });

            renderer.render(scene, useMainCamera ? camera : altCamera);
        }

        // Initialize
        createMilkyWayBackground();
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            altCamera.aspect = width / height;
            altCamera.updateProjectionMatrix();

            renderer.setSize(width, height);
        });

        // Hide loading screen
        document.getElementById('loading').style.display = 'none';
    </script>
</body>
</html>
